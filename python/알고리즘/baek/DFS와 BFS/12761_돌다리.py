'''
문제
동규와 주미는 일직선 상의 돌 다리 위에있다. 돌의 번호는 0 부터 100,000 까지 존재하고 동규는 번 돌 위에, 주미는 번 돌 위에 위치하고 있다. 
동규는 주미가 너무 보고싶기 때문에 최대한 빨리 주미에게 가기 위해  만큼의 힘을 가진 스카이 콩콩을 가져왔다. 
동규가 정한 다리를 건너는 규칙은 턴 방식인데, 한 턴에 이동할 수 있는 거리는 이러하다. 
현 위치에서 +1칸, -1칸을 이동할 수 있고, 스카이 콩콩을 이용해 현 위치에서 나 만큼 좌우로 점프할 수 있으며, 
순간적으로 힘을 모아 현 위치의 배나 배의 위치로 이동을 할 수 있다. 
예를 들어 지금 동규가 7번 돌 위에 있고 스카이 콩콩의 힘이 8이면 그냥 점프를 해서 15번 돌에 갈 수도 있고,
 순간적으로 힘을 모아 56번 돌에 갈 수도 있다는 것이다. 
 주어진 8가지의 방법 중 적절한 방법을 골라서 최대한 빨리 동규가 주미를 만날 수 있게 도와주자. 
 단, 이동 과정에서 100,000보다 크거나 0보다 작은 번호의 돌은 존재하지 않으므로 갈 수 없고, 
 같은 방법을 계속 사용해도 되며 항상 도달할 수 있는 케이스만 주어진다.

입력
입력의 첫 줄에 스카이 콩콩의 힘 와 , 그리고 동규의 현재위치 , 주미의 현재 위치 이 주어진다. (단,  이고  )

출력
동규가 주미에게 도달하기 위한 최소한의 이동 횟수를 출력하라.
'''

# 돌은 0~100,000까지 존재
# 현 위치 +1칸, -1칸 이동 가능
# 현 위치에서 A나 B만큼 좌우로 쩜푸 가능
# 현 위치의 A배, B배의 위치로 이동 가능


# 접근 : 총 8가지 방법에 대해 재귀...?
# 재귀로 풀면, 0, 100000에 각각 위치 하는 경우 최소 100001번 돌것. -> 탈락
# 그냥 큐에 넣고 꺼내기를 반복하면서 최대한 빨리 도착하는 경우를 반환한다.

def BFS(N):
    # 현재 위치가 몇 번째 시도로 도착한 위치인지 계산할 배열
    cnt = [0] * 100001
    # 동규의 현재 위치를 큐에 집어 넣기
    q = [N]
    # 일단은 현재 위치의 카운트를 1로 초기화 (뒤에서 조건문 안걸리기 위함)
    cnt[N] = 1
    while q:
        temp = q.pop(0)
        for i in range(8):
            if i <= 5:
                x = dx[i] + temp
            else:
                x = dx[i] * temp
            if 0 <= x < 100001 and cnt[x] == 0:
                cnt[x] = cnt[temp] + 1
                # 동규가 주미의 위치에 도착했을때? 더이상 반복 돌 필요 없으니까 반환
                if x == M:
                    return cnt[x]
                q.append(x)

# 1번 예제를 풀어보면
# 1번째 for문을 다 돌면? -> 0, 2, 3, 4번 위치가 1이 됨.
# 2번째 for문을 다 돌면? -> 1, 5, 6, 7, 8, 9, 12번 위치가 2가 됨.
# 3번째 for문을 다 돌면? -> 10,11,13, 14, 15,16 18,21,24번 위치가 3이 됨.
# 4번째 for문을 다 돌면? -> 20번 위치가 4가 되면서 밖으로 return됨.   

A, B, N, M = map(int, input().split())
# 현재 위치에서 이동하는 총 8가지 경우
dx = [-1, 1, -A, A, -B, B, A, B]

# 현재 위치에서 탐색 시작
result = BFS(N)
# cnt 배열에서 현재위치를 1로 설정해줬으니까 1 빼주기
print(result-1)