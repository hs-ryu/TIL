'''
문제
주차 빌딩의 원리는 간단하다. 차를 주차 타워의 입구에 있는 엘리베이터에 주차시키고 차에서 내린다. 
엘리베이터와 컨베이어 벨트는 빈 주차 공간을 찾아 그곳으로 이동시킨다. 차를 찾으러 오기 전까지 차는 계속 그곳에 있는다. 
차를 찾으러 오면, 엘리베이터와 컨베이어 벨트는 해당하는 차를 찾아 다시 입구로 가져온다.

주차 빌딩의 레이아웃은 간단하다. 빌딩에는 중앙 엘리베이터가 있고, 차는 엘리베이터를 이용해서 층 사이를 이동할 수 있다. 
각 층에는 거대한 원형 컨베이어 벨트가 있으며, 이 컨베이어 벨트 위에 차가 있다. 벨트는 시계방향, 반시계방향으로 움직일 수 있다. 
엘리베이터가 어떤 층에 도착했을 때, 컨베이어 벨트의 일부가 되며, 차는 엘리베이터를 통과해서 이동할 수 있다.

하루 일과가 끝날 때 쯤이면, 많은 사람들이 차를 다시 찾으러 주차 빌딩으로 온다. 사람들은 온 순서대로 차를 찾을 수 있다. 
엘리베이터는 차가 있는 곳으로 이동하고, 컨베이어 벨트는 차를 엘리베이터에 싣고, 다시 아래로 내려가 고객에게 차를 전달해준다.
 모든 손님이 차를 찾는데 걸리는 시간을 구하는 프로그램을 작성하시오. 
 엘리베이터가 층을 이동하는데 걸리는 시간은 10초이고, 컨베이어 벨트가 차 한 대 만큼 시게방향 또는 반시계방향으로 이동하는데 걸리는 시간은 5초이다. 

입력
첫째 줄에 테스트 케이스의 개수가 주어진다. 테스트 케이스는 최대 100개이다. 각 테스트 케이스의 첫째 줄에는 주차 빌딩의 높이 h와 컨베이어 벨트의 길이 l이 주어진다.
 (1 ≤ h ≤ 50, 2 ≤ l ≤ 50) 다음 h개 줄에는 l개의 정수가 주어지며, 이 정수는 주차 빌딩에 들어있는 차의 정보이다. 
 i번째 줄의 j번째 숫자는 i번 층의 j번 위치에 있는 차의 정보를 나타낸다. 정수가 -1인 경우에는 그 칸이 비어있는 곳이고, 다른 값인 r인 경우에는 r번째 손님이 찾아가는 차라는 의미이다. 
 손님이 차를 1층에서 찾아가고, 엘리베이터는 첫 번째 위치에 있다. 엘리베이터는 처음에 항상 비어있다. 주차 빌딩에 차가 항상 존재하는 경우만 입력으로 주어진다.

출력
각 테스트 케이스마다 모든 손님이 차를 찾는데 걸리는 시간을 출력한다.

'''

# BFS로 안품. BFS로는 도저히 못풀겠음.
# 접근 : 차량이 0번째 자리 올 때까지 회전시키기. 엘베는 0번에 위치함.
# 1. 리스트 배열 받기.
# 2. 1 ~ 총 차량 수 까지 번호가 있을거임. 따라서 배열에서 최대값을 찾음.
# 3. 찾은 최대값을 사용해 반복문을 돌림. 1번부터 차례대로 찾아서 최대값까지 찾기.
# 4. 차량의 인덱스를 찾고, 차량이 있는 row에서 리스트의 성분들을 pop, append(혹은 insert. 현재 위치가 0에 가깝거나 멀거나 따라 다름)해가면서 변화시킴
# 5. 즉 위 4번 작업이 컨베이어 벨트 회전이 되는것임.
# 6. 컨베이어 벨트가 한번 움직일때마다 cnt + 5, 엘리베이터가 움직인 층 만큼 cnt + (10 * 층 수) 해줌
# 6. 모든 차가 다 출차할 때 까지 반복


def find_car(i):
    for r in range(h):
        for c in range(l):
            if building[r][c] == i:
                return r,c

# 시간 계산
def take_time(r,c):
    global cnt

    # 엘베 올라가기
    cnt += r * 10
    
    # 차가 엘리베이터 위치에 올 때 까지 반복
    while c != 0:
        # 왼쪽으로 도는게 0에 더 가까울때
        if c <= l//2:
        # 젤 왼쪽꺼 pop해서 다시 append -> 왼쪽으로 회전
            temp = building[r].pop(0)
            building[r].append(temp)
            c -= 1
            # 한번 움직일때마다 +5 씩
            cnt += 5
        # 오른쪽으로 도는게 0에 더 가까울때 -> 오른쪽으로 회전
        else:
            #젤 오른쪽꺼 pop해서 젤 앞으로 insert
            temp = building[r].pop(-1)
            building[r].insert(0, temp)
            c += 1
            cnt += 5
        if c == l:
            c = 0
    
    # 엘베 내려가기
    cnt += r * 10

T = int(input())
for t in range(T):
    h,l = map(int, input().split())
    building = [list(map(int, input().split())) for _ in range(h)]
    cnt = 0
    # 주차빌딩에 총 차가 몇대 있는지 확인
    total_car = 0
    # 오른쪽으로 돌거나, 왼쪽으로 돌 수 있음
    # 무조건 1번부터 시작할거고, 몇번 까지 있는지 확인
    for floor in building:
        max_floor = max(floor)
        if total_car < max_floor:
            total_car = max_floor

    # 1번부터 찾아서 차 빼기
    i = 1
    while i < total_car + 1:
        r,c = find_car(i)
        take_time(r,c)
        i += 1
    print(cnt)


'''
a = [[1,2,3,4,5], [6,7,8,9,10], [11,12,13,14,15]]
b = a[0].pop(0)
a[0].append(b)
print(a)

b = a[1].pop(-1)
a[1].insert(0, b)
print(a)
'''